.. |orphan| unicode:: U+000A

.. _remote-reference-protocol:

بروتوكول المرجع البعيد
=================

تصف هذه الملاحظة تفاصيل تصميم بروتوكول المرجع البعيد وتشرح تدفق الرسائل في سيناريوهات مختلفة. تأكد من أنك على دراية بـ :ref: `distributed-rpc-framework` قبل المتابعة.

الخلفية
^^^^^^^^

RRef اختصار لـ "Remote REFerence". وهو مرجع لكائن موجود على العامل المحلي أو البعيد، والذي يتعامل مع عد المراجع بشكل شفاف تحت الغطاء. يمكن اعتبارها من الناحية المفاهيمية بمثابة مؤشر مشترك موزع. يمكن للتطبيقات إنشاء RRef عن طريق استدعاء :meth: `~ torch.distributed.rpc.remote`. يمتلك كل RRef بواسطة عامل المستدعي لاستدعاء :meth: `~ torch.distributed.rpc.remote` (أي المالك) ويمكن استخدامه من قبل عدة مستخدمين. يقوم المالك بتخزين البيانات الحقيقية وتتبع عدد المراجع العالمي. يمكن تحديد كل RRef بشكل فريد بواسطة "RRefId" عالمي، والذي يتم تعيينه وقت الإنشاء على المستدعي لاستدعاء :meth: `~ torch.distributed.rpc.remote`.

على عامل المالك، هناك مثيل "OwnerRRef" واحد فقط، والذي يحتوي على البيانات الحقيقية، بينما على عمال المستخدمين، يمكن أن يكون هناك العديد من مثيلات "UserRRefs" حسب الضرورة، ولا يحتفظ "UserRRef" بالبيانات. ستسترد جميع الاستخدامات على المالك مثيل "OwnerRRef" الفريد باستخدام "RRefId" الفريد عالميًا. يتم إنشاء "UserRRef" عند استخدامه كحجة أو قيمة إرجاع في استدعاء :meth: `~ torch.distributed.rpc.rpc_sync`، :meth: `~ torch.distributed.rpc.rpc_async` أو :meth: `~ torch.distributed.rpc.remote`، ويتم إخطار المالك وفقًا لتحديث عدد المراجع. يتم حذف "OwnerRRef" وبياناته عندما لا توجد مثيلات "UserRRef" عالميًا ولا توجد مراجع إلى "OwnerRRef" على المالك أيضًا.

الافتراضات
^^^^^^^^^^^

تم تصميم بروتوكول RRef بناءً على الافتراضات التالية.

- **فشل الشبكة المؤقت**: تتعامل تصميم RRef مع فشل الشبكة المؤقت عن طريق إعادة إرسال الرسائل. لا يمكنه التعامل مع تعطل العقد أو تقسيم الشبكة الدائم. عندما تحدث هذه الحوادث، يجب على التطبيق إيقاف جميع العمال، والعودة إلى نقطة التفتيش السابقة، واستئناف التدريب.
- **وظائف المستخدم غير idempotent**: نفترض أن وظائف المستخدم (UDF) المقدمة إلى :meth: `~ torch.distributed.rpc.rpc_sync`، :meth: `~ torch.distributed.rpc.rpc_async` أو :meth: `~ torch.distributed.rpc.remote` ليست idempotent وبالتالي لا يمكن إعادة المحاولة. ومع ذلك، فإن رسائل التحكم RRef الداخلية idempotent ويتم إعادة المحاولة عند فشل الرسالة.
- **تسليم الرسائل خارج الترتيب**: لا نفترض ترتيب تسليم الرسائل بين أي زوج من العقد، لأن كل من المرسل والمستقبل يستخدم عدة خيوط. لا يوجد ضمان بشأن الرسالة التي سيتم معالجتها أولاً.

عمر RRef
^^^^^^^^^^^^^

هدف البروتوكول هو حذف "OwnerRRef" في الوقت المناسب. الوقت الصحيح لحذف "OwnerRRef" هو عندما لا توجد مثيلات "UserRRef" حية ولا يحتفظ كود المستخدم بمراجع إلى "OwnerRRef" أيضًا. الجزء الصعب هو تحديد ما إذا كانت هناك أي مثيلات "UserRRef" حية.

التبرير التصميمي
----------------

يمكن للمستخدم الحصول على "UserRRef" في ثلاث حالات:

1) استلام "UserRRef" من المالك.
2) استلام "UserRRef" من مستخدم آخر.
3) إنشاء "UserRRef" جديد مملوك لعامل آخر.

الحالة 1 هي أبسط الحالات حيث يقوم المالك بتمرير مرجعه إلى المستخدم، حيث يقوم المالك باستدعاء :meth: `~ torch.distributed.rpc.rpc_sync`، :meth: `~ torch.distributed.rpc.rpc_async`، أو :meth: `~ torch.distributed.rpc.remote` ويستخدم مرجعه كحجة. في هذه الحالة، يتم إنشاء "UserRRef" جديد على المستخدم. نظرًا لأن المالك هو المستدعي، فيمكنه تحديث عدد المراجع المحلية على "OwnerRRef".

الشرط الوحيد هو أنه يجب إخطار المالك عند تدمير أي "UserRRef". وبالتالي، نحتاج إلى الضمان الأول:

**G1. سيتم إخطار المالك عند حذف أي UserRRef.**

نظرًا لأن الرسائل قد تصل متأخرة أو خارج الترتيب، فنحن بحاجة إلى ضمان آخر للتأكد من عدم معالجة رسالة الحذف مبكرًا جدًا. إذا أرسل A رسالة إلى B تتضمن RRef، فإننا نطلق على RRef على A (RRef الأب) وRRef على B (RRef الطفل).

**G2. لن يتم حذف RRef الأب حتى يتم تأكيد RRef الطفل من قبل المالك.**

في الحالتين 2 و3، من الممكن أن يكون لدى المالك معرفة جزئية أو عدم وجود معرفة على الإطلاق حول مخطط تفرع RRef. على سبيل المثال، يمكن إنشاء RRef على مستخدم، وقبل أن يتلقى المالك أي مكالمة RPC، قد يكون المستخدم الذي قام بإنشاء RRef قد شاركه بالفعل مع مستخدمين آخرين، ويمكن لهؤلاء المستخدمين مشاركة RRef بشكل أكبر. تتمثل إحدى الدعائم في أن مخطط التفرع لأي RRef هو دائمًا شجرة، لأن تفرع RRef دائمًا ما ينشئ مثيل "UserRRef" جديدًا على المستدعي (باستثناء إذا كان المستدعي هو المالك)، وبالتالي فإن لكل RRef والدًا واحدًا.

تتكون رؤية المالك لأي "UserRRef" في الشجرة من ثلاث مراحل:

1) غير معروف -> 2) معروف -> 3) محذوف.

تستمر رؤية المالك للشجرة بأكملها في التغيير. يحذف المالك مثيل "OwnerRRef" عندما يعتقد أنه لا توجد مثيلات "UserRRef" حية، أي عندما يتم حذف "OwnerRRef"، يمكن أن تكون جميع مثيلات "UserRRef" إما محذوفة أو غير معروفة. الحالة الخطيرة هي عندما تكون بعض الفروع غير معروفة والبعض الآخر محذوف.

**G2** يضمن بشكل واضح أنه لا يمكن حذف أي "UserRRef" والدي قبل أن يعرف المالك جميع مثيلات "UserRRef" التابعة لها. ومع ذلك، من الممكن أن يتم حذف "UserRRef" الطفل قبل أن يعرف المالك "UserRRef" والديه.

خذ على سبيل المثال، حيث يتفرع "OwnerRRef" إلى A، ثم يتفرع A إلى Y، ويتفرع Y إلى Z:

.. code::

  OwnerRRef -> A -> Y -> Z

إذا تم معالجة جميع رسائل Z، بما في ذلك رسالة الحذف، بواسطة المالك قبل رسائل Y، فسوف يتعلم المالك حذف Z قبل معرفة وجود Y. ومع ذلك، فإن هذا لا يسبب أي مشكلة. لأنه سيكون أحد أسلاف Y على الأقل على قيد الحياة (A) وسيمنع المالك من حذف "OwnerRRef". على وجه التحديد، إذا لم يكن المالك يعرف Y، فلن يتم حذف A بسبب **G2**، ويعرف المالك A منذ أن كان A والديه.

تصبح الأمور أكثر تعقيدًا بعض الشيء إذا تم إنشاء RRef على مستخدم:

.. code::

  OwnerRRef
      ^
      |
      A -> Y -> Z


إذا استدعى Z :meth: `~ torch.distributed.rpc.RRef.to_here` على "UserRRef"، فسيعرف المالك على الأقل A عندما يتم حذف Z، لأنه بخلاف ذلك، لن ينتهي :meth: `~ torch.distributed.rpc.RRef.to_here`. إذا لم يستدع Z :meth: `~ torch.distributed.rpc.RRef.to_here`، فمن الممكن أن يتلقى المالك جميع الرسائل من Z قبل أي رسالة من A وY. في هذه الحالة، نظرًا لأنه لم يتم إنشاء البيانات الحقيقية لـ "OwnerRRef" بعد، فلا يوجد شيء يتم حذفه أيضًا. إنه نفس الشيء كما لو أن Z لا وجود لها على الإطلاق. وبالتالي، لا يزال الأمر على ما يرام.

التنفيذ
-----

يتم تنفيذ **G1** عن طريق إرسال رسالة حذف في دالة محدد "UserRRef". لتوفير **G2**، يتم وضع "UserRRef" الأب في سياق كلما تم تشعبها، مفهرسًا بواسطة "ForkId" الجديد. تتم إزالة "UserRRef" الأب من السياق فقط عند استلامه رسالة تأكيد (ACK) من الطفل، ويرسل الطفل ACK فقط عندما يؤكده المالك.

سيناريوهات البروتوكول
^^^^^^^^^^^^^^

دعونا الآن نناقش كيف تترجم التصميمات المذكورة أعلاه إلى البروتوكول في أربعة سيناريوهات.

مشاركة المستخدم RRef مع المالك كقيمة إرجاع
--------------------------------

.. code::

  import torch
  import torch.distributed.rpc as rpc

  # على العامل A
  rref = rpc.remote ('B'، torch.add، args = (torch.ones (2)، 1))
  # افترض أن rref لديه RRefId 100 وForkId 1
  rref.to_here ()


في هذه الحالة، يتم إنشاء "UserRRef" على عامل المستخدم A، ثم يتم تمريره إلى عامل المالك B جنبًا إلى جنب مع الرسالة البعيدة، ثم يقوم B بإنشاء "OwnerRRef". تعيد طريقة :meth: `~ torch.distributed.rpc.remote` القيمة على الفور، مما يعني أنه يمكن تشعب "UserRRef" / استخدامه قبل أن يعرف المالك عنه.

على المالك، عند استقبال مكالمة :meth: `~ torch.distributed.rpc.remote`، فإنه سيقوم بإنشاء "OwnerRRef"، ويعيد ACK للاعتراف بـ "{100، 1}" ("RRefId"، "ForkId"). فقط بعد استلام هذا ACK، يمكن لـ A حذف "UserRRef" الخاص به. يتضمن هذا كلاً من **G1** و**G2**. **G1** واضح. بالنسبة لـ **G2**، فإن "OwnerRRef" هو طفل "UserRRef"، و"UserRRef" لا يتم حذفه حتى يستلم ACK من المالك.

.. image:: https://user-images\.githubusercontent\.com/16999635/69164772-98181300-0abe-11ea-93a7-9ad9f757cd94.png
    :alt: user_to_owner_ret.png
    :width: 500 px

يوضح الرسم التخطيطي أعلاه تدفق الرسائل، حيث يحتوي السهم الصلب على وظيفة المستخدم والسهم المتقطع هي رسائل مضمنة. لاحظ أن أول رسالتين من A إلى B (:meth: `~ torch.distributed.rpc.remote` و:meth: `~ torch.distributed.rpc.RRef.to_here`) قد تصل إلى B بأي ترتيب، ولكن لن يتم إرسال رسالة الحذف النهائية إلا عندما:

- يؤكد B على "UserRRef {100، 1}" (G2)، و
- توافق Python GC على حذف مثيل "UserRRef" المحلي. يحدث هذا عندما لم يعد RRef في النطاق ويصبح مؤهلاً لجمع القمامة.

مشاركة المستخدم RRef مع المالك كحجة
----------------------------

.. code::

  import torch
  import torch.distributed.rpc as rpc

  # على العامل A والعامل B
  def func (rref):
    pass

  # على العامل A
  rref = rpc.remote ('B'، torch.add، args = (torch.ones (2)، 1))
  # افترض أن rref لديه RRefId 100 وForkId 1
  rpc.rpc_async ('B'، func، args = (rref،))


في هذه الحالة، بعد إنشاء "UserRRef" على A، يستخدمه A كحجة في مكالمة RPC متابعة إلى B. سيحتفظ A بـ "UserRRef {100، 1}" حتى يستلم التأكيد من B (**G2**، وليس قيمة الإرجاع لمكالمة RPC). هذا ضروري لأن A لا يجب أن يرسل رسالة الحذف حتى يتم استلام جميع الرسائل السابقة، وإلا فقد يتم حذف "OwnerRRef" قبل الاستخدام حيث لا نضمن ترتيب تسليم الرسائل. يتم ذلك عن طريق إنشاء "ForkId" طفل لـ RRef، والاحتفاظ بها في خريطة حتى يتم استلام تأكيد المالك لـ "ForkId" الطفل. يوضح الشكل أدناه تدفق الرسائل.

.. image:: https://user-images.githubusercontent.com/16999635/69164845-b67e0e80-0abe-11ea-93fa-d24674e75a2b.png
    :alt: user_to_owner_arg.png
    :width: 500 px

لاحظ أنه يمكن حذف "UserRRef" على B قبل انتهاء func أو حتى البدء. ومع ذلك، هذا أمر جيد، لأنه في الوقت الذي يرسل فيه B ACK لـ "ForkId" الطفل، فقد حصل بالفعل على مثيل "OwnerRRef"، والذي من شأنه أن يمنع حذفه مبكرًا جدًا.

مشاركة المالك RRef مع المستخدم
--------------------------

المالك إلى المستخدم هو أبسط حالة، حيث يمكن للمالك تحديث عدد المراجع محليًا، ولا يحتاج إلى أي رسائل تحكم إضافية لإخطار الآخرين. فيما يتعلق بـ **G2**، فهو نفسه كما لو أن الوالد يتلقى ACK من المالك على الفور، لأن الوالد هو المالك.

.. code::

  import torch
  import torch.distributed.rpc as RRef، rpc

  # على العامل B والعامل C
  def func (rref):
    pass

  # على العامل B، إنشاء RRef محلي
  rref = RRef ("data")
  # افترض أن rref لديه RRefId 100
  dist.rpc_async ('C'، func، args = (rref،))


.. image:: https://user-images.githubusercontent.com/16999635/69164921-c990de80-0abe-11ea-9250-d32ad00cf4ae.png
    :alt: owner_to_user.png
    :width: 500 px

يوضح الشكل أعلاه تدفق الرسائل. لاحظ أنه عندما يخرج "OwnerRRef" من النطاق بعد مكالمة rpc_async، فلن يتم حذفه، لأنه داخليًا توجد خريطة للاحتفاظ به على قيد الحياة إذا كان هناك أي فروع معروفة، وفي هذه الحالة هي "UserRRef {100، 1}". (**G2**)

مشاركة المستخدم RRef مع المستخدم
هذه هي الحالة الأكثر تعقيدًا حيث يحتاج كل من المستخدم المتصل (الوالد ``UserRRef``) والمستخدم المتلقي (الطفل ``UserRRef``) والمالك إلى المشاركة.

.. code::

   import torch
   import torch.distributed.rpc as rpc

   # على العامل A والعامل C
   def func(rref):
     pass

   # على العامل A
   rref = rpc.remote('B', torch.add, args=(torch.ones(2), 1))
   # افترض أن rref له RRefId 100 و ForkId 1
   rpc.rpc_async('C', func, args=(rref, ))

.. image:: https://user-images.githubusercontent.com/16999635/69164971-d6adcd80-0abe-11ea-971d-6b7af131f0fd.png
     :alt: user_to_user.png
     :width: 500 بكسل

عندما يستقبل العامل "سي" الطفل ``UserRRef`` من العامل "أي"، يرسل طلب تفريع إلى المالك "بي". وفي وقت لاحق، عندما يؤكد "بي" ``UserRRef`` على "سي"، سيقوم "سي" بتنفيذ إجراءين بالتوازي: 1) إرسال تأكيد الاستقبال للطفل إلى "أي"، و2) تشغيل الدالة التي قدمها المستخدم. وخلال هذا الوقت، سيحتفظ الوالد (العامل "أي") بـ ``UserRRef {100, 1}`` نشطًا لتحقيق **G2**.