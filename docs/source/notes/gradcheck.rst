.. _gradcheck-mechanics:

آلية فحص التدرج
===================

تقدم هذه الملاحظة نظرة عامة على كيفية عمل دالتَي :meth:`~torch.autograd.gradcheck` و :meth:`~torch.autograd.gradgradcheck`.

ستغطي كل من الوضع الأمامي والخلفي لحساب المشتقات التلقائي لكل من الدوال ذات القيم الحقيقية والمعقدة، بالإضافة إلى المشتقات عالية الرتبة.
تغطي هذه الملاحظة أيضًا السلوك الافتراضي لـ gradcheck بالإضافة إلى الحالة التي يتم فيها تمرير وسيط :code:`fast_mode=True` (يشار إليها باسم fast gradcheck أدناه).

.. contents:: :local:
    :depth: 2

العلامات والمعلومات الأساسية
------------------------------------

على مدار هذه الملاحظة، سنستخدم الاتفاقية التالية:

1. :math:`x`، :math:`y`، :math:`a`، :math:`b`، :math:`v`، :math:`u`، :math:`ur` و :math:`ui` هي متجهات ذات قيم حقيقية و :math:`z` هو متجه بقيم معقدة يمكن إعادة كتابته على أنه متجهين بقيم حقيقية :math:`z = a + i b`.

2. :math:`N` و :math:`M` هما عددان صحيحان سنستخدمهما لأبعاد فضاء الإدخال والإخراج على التوالي.

3. :math:`f: \mathcal{R}^N \to \mathcal{R}^M` هي دالتنا الأساسية الحقيقية إلى الحقيقية بحيث :math:`y = f(x)`.

4. :math:`g: \mathcal{C}^N \to \mathcal{R}^M` هي دالتنا الأساسية المعقدة إلى الحقيقية بحيث :math:`y = g(z)`.


بالنسبة للحالة البسيطة الحقيقية إلى الحقيقية، نكتب :math:`J_f` كمصفوفة جاكوبيانية المقترنة بـ :math:`f` من الحجم :math:`M \times N`.
تحتوي هذه المصفوفة على جميع المشتقات الجزئية بحيث يحتوي الإدخال في الموضع :math:`(i, j)` على :math:`\frac{\partial y_i}{\partial x_j}`.
يقوم الوضع الخلفي لحساب المشتقات التلقائي بحساب الكمية :math:`v^T J_f` لمتجه معطى :math:`v` من الحجم :math:`M`.
من ناحية أخرى، يحسب الوضع الأمامي لحساب المشتقات التلقائي، لمتجه معطى :math:`u` من الحجم :math:`N`، الكمية :math:`J_f u`.

بالنسبة للدوال التي تحتوي على قيم معقدة، فإن القصة أكثر تعقيدًا. نقدم هنا الفكرة الأساسية فقط ويمكن العثور على الوصف الكامل في :ref:`complex_autograd-doc`.

إن القيود اللازمة لتلبية الاشتقاقية المعقدة (معادلات كوشي-ريمان) مقيدة للغاية بالنسبة لجميع دالات الخسارة ذات القيم الحقيقية، لذلك بدلاً من ذلك، اخترنا استخدام حساب ويرتنجر.
في إعداد أساسي لحساب ويرتنجر، تتطلب قاعدة السلسلة الوصول إلى كل من مشتق ويرتنجر (يطلق عليه :math:`W` أدناه) ومشتق ويرتنجر المعقد (يطلق عليه :math:`CW` أدناه).
يجب انتشار كل من :math:`W` و :math:`CW` لأنه بشكل عام، على الرغم من اسمهما، لا يكون أحدهما مرافقًا معقدًا للآخر.

لتجنب الحاجة إلى انتشار كلا القيمتين، بالنسبة للوضع الخلفي لحساب المشتقات التلقائي، نفترض دائمًا أن الدالة التي يتم حساب مشتقها إما دالة ذات قيمة حقيقية أو جزء من دالة حقيقية أكبر. يعني هذا الافتراض أن جميع المشتقات الوسيطة التي نحسبها أثناء المرور الخلفي مرتبطة أيضًا بدوال ذات قيم حقيقية.
في الممارسة العملية، لا يكون هذا الافتراض مقيدًا عند إجراء التحسين لأن مثل هذه المشكلات تتطلب أهدافًا ذات قيم حقيقية (نظرًا لعدم وجود ترتيب طبيعي للأعداد المركبة).

بموجب هذا الافتراض، باستخدام تعريفات :math:`W` و :math:`CW`، يمكننا إظهار أن :math:`W = CW^*` (نستخدم :math:`*` للإشارة إلى الاقتران المركب هنا) وبالتالي فإن إحدى القيمتين فقط تحتاج إلى "الانتشار خلال الرسم البياني" حيث يمكن استرداد القيمة الأخرى بسهولة.
لتبسيط الحسابات الداخلية، يستخدم PyTorch :math:`2 * CW` كقيمة يتم إرجاعها عند طلب المشتقات من قبل المستخدم.
وبشكل مشابه للحالة الحقيقية، عندما يكون الإخراج في :math:`\mathcal{R}^M`، فإن الوضع الخلفي لحساب المشتقات التلقائي لا يحسب :math:`2 * CW` ولكن فقط :math:`v^T (2 * CW)` لمتجه معطى :math:`v \in \mathcal{R}^M`.

بالنسبة للوضع الأمامي لحساب المشتقات التلقائي، نستخدم منطقًا مشابهًا، وفي هذه الحالة نفترض أن الدالة هي جزء من دالة أكبر يكون إدخالها في :math:`\mathcal{R}`. بموجب هذا الافتراض، يمكننا تقديم مطالبة مماثلة بأن كل نتيجة وسيطة تقابل دالة يكون إدخالها في :math:`\mathcal{R}` وفي هذه الحالة، باستخدام تعريفات :math:`W` و :math:`CW`، يمكننا إظهار أن :math:`W = CW` للدوال الوسيطة.
للتأكد من أن الوضعين الأمامي والخلفي يحسبان نفس الكميات في الحالة الأساسية لدالة أحادية البعد، يحسب الوضع الأمامي أيضًا :math:`2 * CW`.
وبشكل مشابه للحالة الحقيقية، عندما يكون الإدخال في :math:`\mathcal{R}^N`، فإن الوضع الأمامي لحساب المشتقات التلقائي لا يحسب :math:`2 * CW` ولكن فقط :math:`(2 * CW) u` لمتجه معطى :math:`u \in \mathcal{R}^N`.


سلوك الوضع الخلفي الافتراضي لـ gradcheck
-----------------------------------

دوال القيم الحقيقية إلى القيم الحقيقية
^^^^^^^^^^^^^^^^^^^^^^

لاختبار دالة :math:`f: \mathcal{R}^N \to \mathcal{R}^M, x \to y`، نقوم بإعادة بناء مصفوفة جاكوبي :math:`J_f` الكاملة من الحجم :math:`M \times N` بطريقتين: تحليليًا وعدديًا.
يستخدم الإصدار التحليلي الوضع الخلفي لحساب المشتقات التلقائي بينما يستخدم الإصدار العددي الفرق المحدود.
ثم تتم مقارنة مصفوفتي جاكوبي المعاد بنائهما عنصرًا تلو الآخر للتساوي.

التقييم العددي الافتراضي للإدخال الحقيقي
""""""""""""""""""""""""""

إذا نظرنا في الحالة الأساسية لدالة أحادية البعد (:math:`N = M = 1`)، فيمكننا استخدام صيغة الفرق المحدود الأساسي من `مقالة ويكيبيديا <https://en.wikipedia.org/wiki/Finite_difference>`_. نستخدم "الفرق المركزي" للحصول على خصائص عددية أفضل:

.. math::
    \frac{\partial y}{\partial x} \approx \frac{f(x + eps) - f(x - eps)}{2 * eps}

تعمم هذه الصيغة بسهولة للعديد من المخرجات (:math:`M \gt 1`) عن طريق جعل :math:`\frac{\partial y}{\partial x}` متجهًا عموديًا من الحجم :math:`M \times 1` مثل :math:`f(x + eps)`.
في هذه الحالة، يمكن إعادة استخدام الصيغة أعلاه كما هي وتقريب مصفوفة جاكوبي الكاملة بتقييمين فقط للدالة التي يستخدمها المستخدم (أي :math:`f(x + eps)` و :math:`f(x - eps)`).

من الأكثر تكلفة حسابياً التعامل مع الحالة ذات المدخلات المتعددة (:math:`N \gt 1`). في هذا السيناريو، نقوم بعمل حلقة حول جميع المدخلات واحدة تلو الأخرى وتطبيق اضطراب :math:`eps` لكل عنصر من :math:`x` واحدًا تلو الآخر. يسمح لنا هذا بإعادة بناء مصفوفة :math:`J_f` عمودًا تلو الآخر.

التقييم التحليلي الافتراضي للإدخال الحقيقي
"""""""""""""""""""""""""""

بالنسبة للتقييم التحليلي، نستخدم الحقيقة، كما هو موضح أعلاه، بأن الوضع الخلفي لحساب المشتقات التلقائي يحسب :math:`v^T J_f`.
بالنسبة للدوال ذات المخرج الأحادي، نستخدم ببساطة :math:`v = 1` لاسترداد مصفوفة جاكوبي الكاملة بتمرير خلفي واحد.

بالنسبة للدوال التي تحتوي على أكثر من مخرج واحد، نلجأ إلى حلقة تكرارية تدور حول المخرجات حيث يكون كل متجه :math:`v` عبارة عن متجه ثنائي الأبعاد يقابل كل مخرج واحدًا تلو الآخر. يسمح هذا بإعادة بناء مصفوفة :math:`J_f` صفًا تلو الآخر.

دوال القيم المعقدة إلى القيم الحقيقية
^^^^^^^^^^^^^^^^^^^^^^

لاختبار دالة :math:`g: \mathcal{C}^N \to \mathcal{R}^M, z \to y` مع :math:`z = a + i b`، نقوم بإعادة بناء المصفوفة (ذات القيمة المعقدة) التي تحتوي على :math:`2 * CW`.

التقييم العددي الافتراضي للإدخال المعقد
""""""""""""""""""""""""""

لنأخذ أولاً في الاعتبار الحالة الأساسية حيث :math:`N = M = 1`. نعلم من (الفصل 3 من) `هذه الورقة البحثية <https://arxiv.org/pdf/1701.00392.pdf>`_ أن:

.. math::
    CW := \frac{\partial y}{\partial z^*} = \frac{1}{2} * (\frac{\partial y}{\partial a} + i \frac{\partial y}{\partial b})

لاحظ أن :math:`\frac{\partial y}{\partial a}` و :math:`\frac{\partial y}{\partial b}`، في المعادلة أعلاه، هما مشتقان من :math:`\mathcal{R} \to \mathcal{R}`.
لحساب هذه القيم عدديًا، نستخدم الطريقة الموضحة أعلاه للحالة الحقيقية إلى الحقيقية.
يسمح لنا هذا بحساب مصفوفة :math:`CW` ثم ضربها بـ :math:`2`.

لاحظ أن الكود، في وقت الكتابة، يحسب هذه القيمة بطريقة ملتوية بعض الشيء:

.. code:: python

    # Code from https://github.com/pytorch/pytorch/blob/58eb23378f2a376565a66ac32c93a316c45b6131/torch/autograd/gradcheck.py#L99-L105
    # تغيير التدوين في كتلة التعليمات البرمجية هذه:
    # s هنا هو y أعلاه
    # x، y هنا a، b أعلاه

    ds_dx = compute_gradient(eps)
    ds_dy = compute_gradient(eps * 1j)
    # مشتق ويرتنجر المعقد
    conj_w_d = 0.5 * (ds_dx + ds_dy * 1j)
    # مشتق ويرتنجر
    w_d = 0.5 * (ds_dx - ds_dy * 1j)
    d[d_idx] = grad_out.conjugate() * conj_w_d + grad_out * w_d.conj()

    # نظرًا لأن grad_out يساوي دائمًا 1، ونظرًا لأن W و CW هما مرافقان معقدان لبعضهما البعض، فإن السطر الأخير يحسب بالضبط `conj_w_d + w_d.conj() = conj_w_d + conj_w_d = 2 * conj_w_d`.


التقييم التحليلي الافتراضي للإدخال المعقد
"""""""""""""""""""""""""""

نظرًا لأن الوضع الخلفي لحساب المشتقات التلقائي يحسب بالفعل ضعف مشتق :math:`CW`، فنحن ببساطة نستخدم نفس الحيلة كما في الحالة الحقيقية إلى الحقيقية هنا ونعيد بناء المصفوفة صفًا تلو الآخر عندما يكون هناك عدة مخرجات حقيقية.

دوال ذات مخرجات معقدة
^^^^^^^^^^^^^^^^^^^

في هذه الحالة، لا تتبع الدالة التي يوفرها المستخدم الافتراض من حساب المشتقات التلقائي بأن الدالة التي نحسب المشتق الخلفي لها ذات قيمة حقيقية.
هذا يعني أن استخدام حساب المشتقات التلقائي مباشرة على هذه الدالة غير محدد جيدًا.
لحل هذا، سنستبدل اختبار الدالة :math:`h: \mathcal{P}^N \to \mathcal{C}^M` (حيث يمكن أن يكون :math:`\mathcal{P}` إما :math:`\mathcal{R}` أو :math:`\mathcal{C}`)، بدالتين: :math:`hr` و :math:`hi` بحيث:

.. math::
    \begin{aligned}
        hr(q) &:= real(f(q)) \\
        hi(q) &:= imag(f(q))
    \end{aligned}

حيث :math:`q \in \mathcal{P}`.
بعد ذلك، نجري اختبارًا أساسيًا لكل من :math:`hr` و :math:`hi` باستخدام الحالة الحقيقية إلى الحقيقية أو المعقدة إلى الحقيقية الموضحة أعلاه، اعتمادًا على :math:`\mathcal{P}`.

لاحظ أن الكود، في وقت الكتابة، لا يقوم بإنشاء هذه الدوال بشكل صريح ولكنه يؤدي قاعدة السلسلة باستخدام دالتَي :math:`real` أو :math:`imag` يدويًا عن طريق تمرير وسيط :math:`\text{grad\_out}` إلى الدوال المختلفة.
عندما :math:`\text{grad\_out} = 1`، فإننا نعتبر :math:`hr`.
عندما :math:`\text{grad\_out} = 1j`، فإننا نعتبر :math:`hi`.


الوضع الخلفي السريع لـ gradcheck
بالرغم من أن الصيغة المذكورة أعلاه لـ "gradcheck" رائعة، سواء لضمان الدقة أو قابلية التصحيح، إلا أنها بطيئة للغاية لأنها تعيد بناء مصفوفات جاكوبي الكاملة.
يقدم هذا القسم طريقة لأداء "gradcheck" بطريقة أسرع دون التأثير على دقتها.
يمكن استعادة قابلية التصحيح عن طريق إضافة منطق خاص عند اكتشاف خطأ. في هذه الحالة، يمكننا تشغيل الإصدار الافتراضي الذي يعيد بناء المصفوفة الكاملة لتزويد المستخدم بجميع التفاصيل.

تتمثل الاستراتيجية العامة هنا في إيجاد كمية قياسية يمكن حسابها بكفاءة بواسطة الأساليب العددية والتحليلية، والتي تمثل المصفوفة الكاملة التي يحسبها "gradcheck" البطيء بما فيه الكفاية لضمان التقاط أي تباين في مصفوفات جاكوبي.

التحقق السريع من التدرج للوظائف الحقيقية إلى الحقيقية
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

الكمية القياسية التي نريد حسابها هنا هي :math:`v^T J_f u` بالنسبة إلى متجه عشوائي :math:`v \in \mathcal{R}^M` ومتجه وحدة عشوائي :math:`u \in \mathcal{R}^N`.

بالنسبة للتقييم العددي، يمكننا حساب ما يلي بكفاءة:

.. math::
    J_f u \approx \frac{f(x + u * eps) - f(x - u * eps)}{2 * eps}.

بعد ذلك، نقوم بحساب الضرب النقطي بين هذا المتجه و :math:`v` للحصول على القيمة القياسية المطلوبة.

بالنسبة للإصدار التحليلي، يمكننا استخدام طريقة "backward mode AD" لحساب :math:`v^T J_f` مباشرة. ثم نقوم بحساب الضرب النقطي مع :math:`u` للحصول على القيمة المتوقعة.

التحقق السريع من التدرج للوظائف المعقدة إلى الحقيقية
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

على غرار حالة الحقيقي إلى الحقيقي، نريد إجراء تقليل للمصفوفة الكاملة. ولكن مصفوفة :math:`2 * CW` هي ذات قيم معقدة، لذا في هذه الحالة، سنقارن بالقياسات المعقدة.

بسبب بعض القيود على ما يمكننا حسابه بكفاءة في الحالة العددية وللحفاظ على عدد التقييمات العددية عند الحد الأدنى، نحسب ما يلي (على الرغم من المفاجئ) القيمة القياسية:

.. math::
    s := 2 * v^T (real(CW) ur + i * imag(CW) ui)

حيث :math:`v \in \mathcal{R}^M`، :math:`ur \in \mathcal{R}^N` و :math:`ui \in \mathcal{R}^N`.

التقييم العددي السريع للإدخال المعقد
""""""""""""""""""""""""""

ننظر أولاً في كيفية حساب :math:`s` باستخدام طريقة عددية. للقيام بذلك، مع مراعاة أننا ننظر في :math:`g: \mathcal{C}^N \to \mathcal{R}^M, z \to y` مع :math:`z = a + i b`، وأن :math:`CW = \frac{1}{2} * (\frac{\partial y}{\partial a} + i \frac{\partial y}{\partial b})`، نعيد كتابتها على النحو التالي:

.. math::
    \begin{aligned}
        s &= 2 * v^T (real(CW) ur + i * imag(CW) ui) \\
          &= 2 * v^T (\frac{1}{2} * \frac{\partial y}{\partial a} ur + i * \frac{1}{2} * \frac{\partial y}{\partial b} ui) \\
          &= v^T (\frac{\partial y}{\partial a} ur + i * \frac{\partial y}{\partial b} ui) \\
          &= v^T ((\frac{\partial y}{\partial a} ur) + i * (\frac{\partial y}{\partial b} ui))
    \end{aligned}

في هذه المعادلة، يمكننا أن نرى أن :math:`\frac{\partial y}{\partial a} ur` و :math:`\frac{\partial y}{\partial b} ui` يمكن تقييمها بنفس طريقة الإصدار السريع لحالة الحقيقي إلى الحقيقي.
بمجرد حساب هذه الكميات ذات القيم الحقيقية، يمكننا إعادة بناء المتجه المعقد على الجانب الأيمن وإجراء ضرب نقطي مع المتجه :math:`v` ذي القيمة الحقيقية.

التقييم التحليلي السريع للإدخال المعقد
""""""""""""""""""""""""

بالنسبة للحالة التحليلية، تكون الأمور أبسط، ونعيد كتابة المعادلة على النحو التالي:

.. math::
    \begin{aligned}
        s &= 2 * v^T (real(CW) ur + i * imag(CW) ui) \\
          &= v^T real(2 * CW) ur + i * v^T imag(2 * CW) ui) \\
          &= real(v^T (2 * CW)) ur + i * imag(v^T (2 * CW)) ui
    \end{aligned}

لذلك، يمكننا استخدام حقيقة أن طريقة "backward mode AD" توفر لنا طريقة فعالة لحساب :math:`v^T (2 * CW)`، ثم نقوم بحساب الضرب النقطي للجزء الحقيقي مع :math:`ur` والجزء التخيلي مع :math:`ui` قبل إعادة بناء القيمة المعقدة القياسية النهائية :math:`s`.

لماذا لا نستخدم متجهًا معقدًا :math:`u`
""""""""""""""""""""""""""""

في هذه المرحلة، قد تتساءل عن سبب عدم اختيار متجه معقد :math:`u` والقيام ببساطة بالتخفيض :math:`2 * v^T CW u'`.
للغوص في هذا الموضوع، في هذه الفقرة، سنستخدم الإصدار المعقد من :math:`u` الملاحظ على أنه :math:`u' = ur' + i ui'`.
باستخدام :math:`u` معقد، تكمن المشكلة في أنه عند إجراء التقييم العددي، سيتعين علينا حساب ما يلي:

.. math::
    \begin{aligned}
        2*CW u' &= (\frac{\partial y}{\partial a} + i \frac{\partial y}{\partial b})(ur' + i ui') \\
                &= \frac{\partial y}{\partial a} ur' + i \frac{\partial y}{\partial a} ui' + i \frac{\partial y}{\partial b} ur' - \frac{\partial y}{\partial b} ui'
    \end{aligned}

والذي سيتطلب أربعة تقييمات للفرق المحدود الحقيقي إلى الحقيقي (ضعف ما هو مقترح أعلاه).
نظرًا لأن هذا النهج لا يحتوي على درجات حرية أكثر (نفس عدد المتغيرات ذات القيم الحقيقية) ونحاول الحصول على أسرع تقييم ممكن هنا، فإننا نستخدم الصيغة الأخرى المذكورة أعلاه.

التحقق السريع من التدرج للوظائف ذات المخرجات المعقدة
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

تمامًا كما هو الحال في الحالة البطيئة، نأخذ دالتين ذواتي قيم حقيقية ونستخدم القاعدة المناسبة من الأعلى لكل دالة.

تنفيذ "Gradgradcheck"
-----------------------------

يوفر PyTorch أيضًا أداة مساعدة للتحقق من تدرجات الرتبة الثانية. الهدف هنا هو التأكد من أن التنفيذ العكسي قابل للاشتقاق أيضًا ويحسب الشيء الصحيح.

تم تنفيذ هذه الميزة من خلال النظر في الدالة :math:`F: x, v \to v^T J_f` واستخدام "gradcheck" المحدد أعلاه على هذه الدالة.
لاحظ أن :math:`v` في هذه الحالة هو مجرد متجه عشوائي من نفس نوع :math:`f(x)`.

يتم تنفيذ الإصدار السريع من "gradgradcheck" من خلال استخدام الإصدار السريع من "gradcheck" على نفس الدالة :math:`F`.