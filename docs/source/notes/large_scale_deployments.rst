مميزات النشر على نطاق واسع
=====================

.. contents:: :local:

تتحدث هذه الملاحظة عن عدة نقاط تمديد وحيل قد تكون مفيدة عند تشغيل PyTorch ضمن نظام أكبر أو تشغيل أنظمة متعددة باستخدام PyTorch في منظمة أكبر.

لا يغطي المواضيع المتعلقة بنشر النماذج في الإنتاج. تحقق من :mod: `torch.jit` أو إحدى البرامج التعليمية المقابلة.

تفترض الملاحظة أنك إما تقوم ببناء PyTorch من المصدر في مؤسستك أو لديك القدرة على الربط الثابت للرمز الإضافي ليتم تحميله عند استخدام PyTorch. وبالتالي، يتم عرض العديد من الخطافات على أنها واجهات برمجة تطبيقات C++ التي يمكن تشغيلها مرة واحدة في مكان مركزي، على سبيل المثال، في رمز التهيئة الثابت.

الملف الشخصي للمشغل على مستوى الأسطول
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

يأتي PyTorch مع :mod: `torch.autograd.profiler` القادر على قياس الوقت الذي يستغرقه المشغلون الفرديون عند الطلب. يمكن للمرء استخدام نفس الآلية للقيام بقياسات "دائمًا ON" لأي عملية تشغيل PyTorch. قد يكون ذلك مفيدًا لجمع معلومات حول أحمال عمل PyTorch التي تعمل في عملية معينة أو عبر مجموعة كاملة من الآلات.

يمكن إضافة استدعاءات جديدة لأي استدعاء مشغل باستخدام ``torch::addGlobalCallback``. سيتم استدعاء الخطافات مع ``torch::RecordFunction`` struct الذي يصف سياق الاستدعاء (على سبيل المثال `name`). إذا تم تمكينه، يحتوي ``RecordFunction::inputs()`` على حجج الدالة الممثلة كنوع متغير ``torch::IValue``. لاحظ أن تسجيل المدخلات مكلف نسبيًا وبالتالي يجب تمكينه بشكل صريح.

كما تتوفر للمكالمات الخلفية للمشغل واجهة ``c10::ThreadLocalDebugInfo::get()`` التي تعيد مؤشرًا إلى struct الذي يحمل معلومات التصحيح. يمكن تعيين معلومات التصحيح مسبقًا باستخدام كائن ``at::DebugInfoGuard``. يتم تمرير معلومات التصحيح عبر التمريرات الأمامية (بما في ذلك مهام "fork" غير المتزامرة) والخلفية ويمكن أن تكون مفيدة لتمرير بعض المعلومات الإضافية حول بيئة التنفيذ (على سبيل المثال، معرف النموذج) من الطبقات العليا للتطبيق وصولاً إلى استدعاءات المشغل الخلفية.

يضيف استدعاء الاستدعاءات الخلفية بعض النفقات العامة، لذلك من المفيد عادةً أخذ عينات عشوائية من استدعاءات المشغل فقط. يمكن تمكين ذلك على أساس كل استدعاء خلفي بمعدل أخذ عينات اختياري يتم تمريره إلى ``torch::addGlobalCallback``.

لاحظ أن ``addGlobalCallback`` ليس آمنًا للخيوط ولا يمكن استدعاؤه إلا عندما لا يتم تشغيل أي مشغل PyTorch. عادة، فكرة جيدة لاستدعائهم مرة واحدة أثناء التهيئة.

فيما يلي مثال:

.. code-block:: cpp

    // يتم استدعاؤه في مكان ما في بداية البرنامج
    void init() {
        // عيّنة واحدة في مائة من عمليات تشغيل المشغل بشكل عشوائي
        addGlobalCallback(
          RecordFunctionCallback(
            &onFunctionEnter,
            &onFunctionExit)
          .needsInputs(true)
          .samplingProb(0.01)
        );
        // ملاحظة: لتمكين المراقبين في خيط نموذج الاستدعاء،
        // استدعاء enableRecordFunction() في الخيط قبل تشغيل نموذج
    }

    void onFunctionEnter(const RecordFunction& fn) {
        std::cerr << "قبل الدالة " << fn.name()
                  << " مع " << fn.inputs().size() << " المدخلات" << std::endl;
    }

    void onFunctionExit(const RecordFunction& fn) {
        std::cerr << "بعد الدالة " << fn.name();
    }

تسجيل استخدام واجهة برمجة التطبيقات
^^^^^^^^^^^^^^^^^^^^^^^^^^

عند التشغيل في نظام بيئي أوسع، على سبيل المثال في مسؤول جدولة الوظائف المُدارة، من المفيد غالبًا تتبع الثنائيات التي تستدعي واجهات برمجة تطبيقات PyTorch معينة. هناك أدوات بسيطة يتم حقنها في عدة نقاط واجهة برمجة تطبيقات مهمة تؤدي إلى تشغيل استدعاء معين. نظرًا لأن PyTorch يتم استدعاؤه عادةً في نصوص Python لمرة واحدة، يتم تشغيل الاستدعاء مرة واحدة فقط لعملية معينة لكل من واجهات برمجة التطبيقات.

يمكن استخدام ``c10::SetAPIUsageHandler`` لتسجيل معالج أدوات API usage instrumentation. سوف يكون الحجة التي تم تمريرها "مفتاح api" الذي يحدد نقطة الاستخدام، على سبيل المثال ``python.import`` لاستيراد PyTorch أو ``torch.script.compile`` إذا تم تشغيل تجميع TorchScript.

.. code-block:: cpp

    SetAPIUsageLogger([](const std::string& event_name) {
        std::cerr << "تم استخدام واجهة برمجة التطبيقات: " << event_name << std::endl;
    });

ملاحظة للمطورين: يمكن إضافة نقاط تشغيل أدوات جديدة في التعليمات البرمجية باستخدام ``C10_LOG_API_USAGE_ONCE ("my_api")`` في C++ أو ``torch._C._log_api_usage_once ("my.api")`` في Python.

ربط البيانات الوصفية بنماذج TorchScript المحفوظة
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

يمكن حفظ وحدات TorchScript كملف أرشيف يقوم بتجميع المعلمات والرمز المُسلسل كـ TorchScript (راجع: meth: `torch.jit.save`). غالبًا ما يكون من الملائم تجميع معلومات إضافية مع النموذج، على سبيل المثال، وصف منتج النموذج أو القطع الأثرية المساعدة.

يمكن تحقيق ذلك عن طريق تمرير الحجة ``_extra_files`` إلى: meth: `torch.jit.save` و ``torch::jit::load`` لتخزين واسترداد كتل ثنائية عشوائية أثناء عملية الحفظ. نظرًا لأن ملفات TorchScript عبارة عن أرشيفات ZIP عادية، يتم تخزين المعلومات الإضافية كملفات عادية داخل دليل "extra/" في الأرشيف.

هناك أيضًا خطاف عالمي يسمح بضم ملفات إضافية إلى أي أرشيف TorchScript يتم إنتاجه في العملية الحالية. قد يكون من المفيد وضع علامات على النماذج باستخدام بيانات التعريف الخاصة بالمنتج، على غرار بيانات التعريف JPEG التي تنتجها الكاميرات الرقمية. قد يبدو الاستخدام النموذجي على النحو التالي:

.. code-block:: cpp

    SetExportModuleExtraFilesHook([](const Module&) {
        ExtraFilesMap files;
        files["producer_info.json"] = "{\"user\": \"" + getenv("USER") + "\"}";
        return files;
    });

اعتبارات بيئة البناء
^^^^^^^^^^^^^^^

يتطلب تجميع TorchScript الوصول إلى ملفات Python الأصلية حيث يستخدم مكالمة ``inspect.getsource`` في Python. في بعض بيئات الإنتاج، قد يتطلب ذلك نشر ملفات ``.py`` جنبًا إلى جنب مع ملفات ``.pyc`` المُجمّعة مسبقًا.

نقاط التمديد الشائعة
^^^^^^^^^^^^^^

بشكل عام، تكون واجهات برمجة تطبيقات PyTorch مفككة بشكل فضفاض ومن السهل استبدال مكون بإصدار متخصص. تشمل نقاط التمديد الشائعة ما يلي:

* المشغلون المخصصون المنفذون في C++ - راجع `البرنامج التعليمي لمزيد من التفاصيل <https://pytorch.org/tutorials/advanced/cpp_extension.html>`_.
* يمكن غالبًا دمج قراءة البيانات المخصصة مباشرة عن طريق استدعاء مكتبة Python المقابلة. يمكن الاستفادة من الوظائف الموجودة في: mod: `torch.utils.data` عن طريق توسيع: class: `~torch.utils.data.Dataset` أو: class: `~torch.utils.data.IterableDataset`.