.. _torchdynamo_fine_grain_tracing:

واجهات برمجة تطبيقات TorchDynamo للتعقب الدقيق للحبوب
=============================================

.. note:: في هذه الوثيقة، يتم استخدام "torch.compiler.compile" و
   "torch.compile" بشكل متبادل. ستعمل كلا النسختين
   في كودك.

تؤدي ``torch.compile`` تتبع TorchDynamo على كامل نموذج المستخدم.
ومع ذلك، من الممكن أن يكون جزء صغير من كود النموذج غير قادر على
التعامل مع ``torch.compiler``. في هذه الحالة، قد ترغب في تعطيل
المترجم على ذلك الجزء المحدد، مع تشغيل التجميع على
بقية النموذج. يصف هذا القسم واجهات برمجة التطبيقات الموجودة التي
يتم استخدامها لتحديد أجزاء الكود التي تريد تخطي التجميع فيها وحالات الاستخدام ذات الصلة.

يتم سرد واجهة برمجة التطبيقات التي يمكنك استخدامها لتحديد أجزاء الكود التي يمكنك من خلالها
تعطيل التجميع في الجدول التالي:

.. csv-table:: واجهات برمجة تطبيقات TorchDynamo للتحكم في التعقب الدقيق للحبوب
   :header: "واجهة برمجة التطبيقات", "الوصف", "متى تستخدم؟"
   :widths: auto

   "``torch.compiler.disable``", "يعطل Dynamo على الدالة المزينة وكذلك الوظائف المستدعاة بشكل متكرر.", "ممتاز لإلغاء حظر المستخدم، إذا كان جزء صغير من النموذج لا يمكن التعامل معه باستخدام ``torch.compile``."
   "``torch._dynamo.disallow_in_graph``", "يمنع العملية المحددة في مخطط TorchDynamo. يتسبب TorchDynamo في حدوث كسر في المخطط، ويقوم بتشغيل العملية في الوضع الحريص (بدون تجميع)\n\nهذا مناسب للعمليات، في حين أن ``torch.compiler.disable`` مناسب لتزيين الوظائف.", "تعد واجهة برمجة التطبيقات هذه ممتازة لكل من التصحيح وإلغاء الحظر إذا كانت عملية مخصصة مثل ``torch.ops.fbgemm.*`` تسبب مشكلات مع دالة ``torch.compile``."
   "``torch.compile.allow_in_graph``", "تتم إضافة الدالة المشروحة كما هي في مخطط TorchDynamo. على سبيل المثال، صندوق أسود لشركة TorchDynamo.\n\nملاحظة: ستتبع AOT Autograd من خلاله، لذا فإن ``allow_in_graph`` هو مجرد مفهوم على مستوى Dynamo.", "تعد واجهة برمجة التطبيقات هذه مفيدة لأجزاء النموذج التي تحتوي على ميزات يصعب على TorchDynamo دعمها، مثل الخطافات أو ``autograd.Function``. ومع ذلك، يجب فحص كل استخدام لـ ``allow_in_graph`` **بعناية** (بدون كسور في المخطط، بدون إغلاقات)."
   "``torch._dynamo.graph_break``", "يضيف كسرًا في المخطط. يتم تمرير الكود قبل وبعد كسر المخطط عبر TorchDynamo.", "**نادرًا ما يكون مفيدًا للنشر** - إذا كنت تعتقد أنك بحاجة إلى هذا، فمن المحتمل أن تحتاج إما إلى ``disable`` أو ``disallow_in_graph``."
   "``torch.compiler.is_compiling``", "يشير إلى ما إذا كان المخطط يتم تنفيذه/تتبعه كجزء من torch.compile() أو torch.export()."
   "``torch.compiler.is_dynamo_compiling``", "يشير إلى ما إذا كان المخطط يتم تتبعه عبر TorchDynamo. إنه أكثر صرامة من علم ``torch.compiler.is_compiling()``، حيث لن يتم تعيينه إلى True إلا عند استخدام TorchDynamo."

``torch.compiler.disable``
~~~~~~~~~~~~~~~~~~~~~~~~~~

يعطل ``torch.compiler.disable`` التجميع على إطار الدالة المزين وجميع أطر الوظائف المستدعاة بشكل متكرر من إطار الدالة المزين.

تتعترض TorchDynamo تنفيذ كل إطار دالة Python. لذا، افترض أن لديك هيكل كود (الصورة أدناه) حيث تقوم الدالة ``fn`` باستدعاء الدالتين ``a_fn`` و ``b_fn``. وتقوم ``a_fn`` باستدعاء ``aa_fn`` و ``ab_fn``. عند استخدام الوضع الحريص لـ PyTorch بدلاً من ``torch.compile``، يتم تشغيل أطر هذه الدوال كما هي. مع ``torch.compile``، تتعترض TorchDynamo كل إطار من أطر هذه الدوال (يشير اللون الأخضر إلى ذلك):

.. figure:: _static/img/fine_grained_apis/api_diagram.png
   :alt: مخطط مكدس الاستدعاء لواجهات برمجة التطبيقات المختلفة.

لنفترض أن الدالة ``a_fn`` تسبب مشكلات مع ``torch.compile``.
وهذا جزء غير مهم من النموذج. يمكنك استخدام ``compiler.disable``
على الدالة ``a_fn``. كما هو موضح أعلاه، ستتوقف TorchDynamo عن النظر في الأطر
الناشئة عن استدعاء ``a_fn`` (يشير اللون الأبيض إلى سلوك Python الأصلي).

لتخطي التجميع، يمكنك تزيين الدالة المخالفة باستخدام
``@torch.compiler.disable``.

يمكنك أيضًا استخدام بناء جملة غير المزين إذا كنت لا تريد تغيير كود المصدر
ومع ذلك، نوصي بتجنب هذا الأسلوب إذا أمكن. هنا، يجب عليك
الاهتمام بأن جميع مستخدمي الدالة الأصلية يستخدمون الآن الإصدار المعدل.

``torch._dynamo.disallow_in_graph``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

يمنع ``torch._dynamo.disallow_in_graph`` عملية، وليس الدالة
أن تكون موجودة في المخطط المستخرج من TorchDynamo. لاحظ أن هذا مناسب
للعمليات وليس للوظائف العامة كما هو الحال في ``_dynamo.disable``.

لنفترض أنك تقوم بتجميع نموذجك باستخدام PyTorch. يمكن لـ TorchDynamo استخراج مخطط، ولكن بعد ذلك ترى فشل المترجم الأساسي. على سبيل المثال،
تفقد نواة ميتا، أو يتم تعيين مفتاح إرسال Autograd بشكل غير صحيح
لعملية معينة. بعد ذلك، يمكنك وضع علامة على تلك العملية على أنها
``disallow_in_graph``، وسيتسبب TorchDynamo في حدوث كسر في المخطط وتشغيل
تلك العملية باستخدام الوضع الحريص لـ PyTorch.

المشكلة هي أنه سيتعين عليك العثور على العملية على مستوى Dynamo،
وليس عملية ATen. راجع المزيد في قسم القيود في الوثيقة.

.. warning::
   ``torch._dynamo.disallow_in_graph`` هو علم عالمي. إذا كنت تقارن
مترجمين خلفيين مختلفين، فقد تضطر إلى استدعاء ``allow_in_graph`` لـ
العملية غير المسموح بها عند التبديل إلى المترجم الآخر.

``torch.compiler.allow_in_graph``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

مفيد عندما يحتوي إطار الدالة ذات الصلة على بعض الميزات المعروفة التي يصعب على TorchDynamo دعمها، مثل الخطافات و
``autograd.Function``، وأنت واثق من أن مكونات PyTorch الأساسية
مثل AOTAutograd يمكنها تتبع الدالة المزينة بأمان. عندما يتم تزيين دالة باستخدام ``allow_in_graph``، فإن TorchDynamo تعاملها ك
صندوق أسود وتضيفها كما هي في المخطط الناتج.

.. warning::
   تخطي ``allow_in_graph`` TorchDynamo تمامًا على الدالة المزينة
   تخطي جميع فحوصات الأمان في TorchDynamo، بما في ذلك كسور المخطط، ومعالجة
الإغلاقات، وغيرها. استخدم ``allow_in_graph`` بحذر. تعتمد مكونات PyTorch الأساسية، مثل AOTAutograd
على TorchDynamo للتعامل مع ميزات Python المعقدة، ولكن ``allow_in_graph`` يتجاوز TorchDynamo. قد يؤدي استخدام ``allow_in_graph``
إلى مشكلات في الصلاحية والتصحيح.

القيود
~~~~

تتم تطبيق جميع واجهات برمجة التطبيقات الموجودة على مستوى TorchDynamo. لذلك، هذه
لدى واجهات برمجة التطبيقات هذه رؤية لما تراه TorchDynamo فقط. قد يؤدي هذا إلى سيناريوهات محيرة.

على سبيل المثال، لن يعمل ``torch._dynamo.disallow_in_graph`` لعمليات ATen
لأنها مرئية لـ AOT Autograd. على سبيل المثال،
``torch._dynamo.disallow_in_graph(torch.ops.aten.add)`` لن يعمل في
المثال أعلاه.