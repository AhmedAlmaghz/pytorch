مبادئ تصميم PyTorch
====================

تم تصميم هذه الوثيقة لمساعدة المساهمين والقائمين على الوحدات النمطية على فهم مبادئ التصميم عالية المستوى التي تطورت بمرور الوقت في PyTorch. لا يقصد بها أن تكون قواعد ثابتة، ولكن لتكون بمثابة دليل للمساعدة في الموازنة بين مختلف الشواغل وحل الخلافات التي قد تنشأ أثناء تطوير PyTorch. لمزيد من المعلومات حول المساهمة، وإدارة الوحدات النمطية، وكيفية تصعيد الخلاف إلى القائمين على الصيانة الأساسيين، يرجى الاطلاع على "حوكمة PyTorch" <https://pytorch.org/docs/main/community/governance.html>`__.

مبادئ التصميم
-----------------

المبدأ 1: قابلية الاستخدام قبل الأداء
~~~~~~~~~~~~~~~~~~~~~~~~~

قد يكون هذا المبدأ مفاجئًا! وكما كتب أحد المشاركين في Hacker News: "إن PyTorch رائع! [...] على الرغم من أنني محتار. كيف يمكن لإطار عمل التعلم الآلي ألا يكون مهووسًا بالسرعة/الأداء؟" راجع "مناقشة Hacker News حول PyTorch <https://news.ycombinator.com/item?id=28066093>`__.

تتطرق التدوينة التي كتبها Soumith على المدونة حول "تنمية مجتمع PyTorch" <https://soumith.ch/posts/2021/02/growing-opensource/?fbclid=IwAR1bvN_xZ8avGvu14ODJzS8Zp7jX1BOyfuGUf-zoRawpyL-s95Vjxf88W7s>`__ إلى هذا الموضوع ببعض العمق، ولكن على مستوى عالٍ:

-  الهدف الأساسي لـ PyTorch هو قابلية الاستخدام
-  الهدف الثانوي هو تحقيق أداء "معقول"

نعتقد أن القدرة على الحفاظ على مرونتها لدعم الباحثين الذين يبنون على أساس تجريداتنا لا تزال بالغة الأهمية. لا يمكننا أن نرى مستقبل أعباء العمل، ولكننا نعرف أننا نريد بنائها أولاً على PyTorch وأن ذلك يتطلب المرونة.

وبعبارات أكثر تحديدًا، نعمل بطريقة "قابلية الاستخدام أولاً" ونحاول تجنب الانتقال إلى أنظمة "التقييد أولاً" (على سبيل المثال، الأشكال الثابتة، ووضع الرسم البياني فقط) دون رؤية واضحة للمقايضات. غالبًا ما يكون هناك إغراء لفرض قيود صارمة على المستخدمين مقدمًا لأن ذلك يمكن أن يبسط التنفيذ، ولكن هذا يأتي مع مخاطر:

-  قد لا يكون الأداء يستحق الاحتكاك بالمستخدم، إما لأن فائدة الأداء ليست مقنعة بما يكفي أو لأنها تنطبق فقط على مجموعة فرعية ضيقة من المشكلات الفرعية.
-  حتى إذا كانت فائدة الأداء مقنعة، يمكن أن تؤدي القيود إلى تجزئة النظام البيئي إلى مجموعات مختلفة من القيود التي يمكن أن تصبح غير مفهومة بسرعة للمستخدمين.

نريد أن يكون المستخدمون قادرين على نقل رمز PyTorch بسلاسة إلى أجهزة وبرامج مختلفة، والتفاعل مع المكتبات والأطر المختلفة، وتجربة ثراء تجربة المستخدم PyTorch، وليس مجموعة فرعية من القواسم المشتركة الصغرى.

المبدأ 2: البساطة قبل السهولة
~~~~~~~~~~~~~~~~~~~~~

هنا، نستعير من "تأملات في لغة بايثون" <https://peps.python.org/pep-0020/>`__:

-  *من الأفضل أن تكون صريحًا من أن تكون ضمنيًا*
-  *البساطة أفضل من التعقيد*

طريقة أكثر إيجازًا لوصف هذين الهدفين هي "البساطة قبل السهولة" <https://www.infoq.com/presentations/Simple-Made-Easy/>`_. دعونا نبدأ بمثال لأن "البساطة" و"السهولة" غالبًا ما يتم استخدامهما بشكل متبادل في اللغة الإنجليزية اليومية. ضع في اعتبارك كيف يمكنك نمذجة "الأجهزة" <https://pytorch.org/docs/main/tensor_attributes.html#torch.device>`__ في PyTorch:

-  **البساطة / الصراحة (لفهم، والتصحيح):** ترتبط كل مصفوفة بجهاز. يحدد المستخدم صراحة حركة مصفوفة الجهاز. تؤدي العمليات التي تتطلب حركة بين الأجهزة إلى حدوث خطأ.
-  **السهولة / الضمنية (للاستخدام):** لا يتعين على المستخدم القلق بشأن الأجهزة؛ يحدد النظام الموضع الأمثل للأجهزة على مستوى العالم.

في هذه الحالة المحددة، وكمبدأ تصميم عام، يفضل PyTorch عرض كتل بناء بسيطة وصريحة بدلاً من واجهات برمجة التطبيقات التي يسهل على الممارسين استخدامها. يمكن فهم الإصدار البسيط على الفور وتصحيحه من قبل مستخدم PyTorch الجديد: فأنت تحصل على خطأ واضح إذا قمت باستدعاء مشغل يتطلب حركة بين الأجهزة في النقطة في البرنامج حيث يتم استدعاء المشغل بالفعل. قد تسمح لك الحل السهل بالتحرك بشكل أسرع في البداية، ولكن قد يكون تصحيح مثل هذا النظام معقدًا: كيف توصل النظام إلى قراره؟ ما هي واجهة برمجة التطبيقات للتوصيل في مثل هذا النظام وكيف يتم تمثيل الكائنات في تمثيله المتوسط؟

تأتي بعض الحجج الكلاسيكية لصالح هذا النوع من التصميم من "ملاحظة حول الحساب الموزع" <https://dl.acm.org/doi/book/10.5555/974938>`__ (خلاصة القول: لا تقم بنمذجة الموارد ذات خصائص الأداء المختلف بشكل كبير بشكل موحد، فستتسرب التفاصيل) و"المبدأ من البداية إلى النهاية" <http://web.mit.edu/Saltzer/www/publications/endtoend/endtoend.pdf>`__ (خلاصة القول: يمكن أن يؤدي بناء الذكاء في الطبقات السفلية من المكدس إلى منع بناء ميزات الأداء في الطبقات العليا في المكدس، وغالبًا ما لا يعمل على أي حال). على سبيل المثال، يمكننا بناء قواعد حركة الأجهزة على مستوى المشغل أو على مستوى العالم، ولكن الخيارات الدقيقة ليست واضحة وبناء آلية قابلة للتمديد لها تعقيدات وتكاليف تأخير لا مفر منها.

التحذير هنا هو أن هذا لا يعني أن واجهات برمجة التطبيقات "السهلة" عالية المستوى ليست مفيدة؛ بالتأكيد هناك قيمة في، على سبيل المثال، دعم الطبقات العليا في المكدس لحسابات المصفوفة الفعالة عبر الحوسبة الموزعة في مجموعة كبيرة. بدلاً من ذلك، ما نعنيه هو أن التركيز على كتل البناء البسيطة منخفضة المستوى يساعد في إبلاغ واجهة برمجة التطبيقات السهلة مع الحفاظ على تجربة جيدة عندما يحتاج المستخدمون إلى الخروج عن الطريق المطروق. كما أنه يتيح مساحة للابتكار ونمو الأدوات الأكثر تعبيرًا عن الرأي بمعدل لا يمكننا دعمه في المكتبة الأساسية لـ PyTorch، ولكننا نستفيد منها في النهاية، كما يتضح من نظامنا البيئي الغني <https://pytorch.org/ecosystem/>`__. بعبارة أخرى، فإن عدم التشغيل الآلي في البداية يسمح لنا بالوصول إلى مستويات من التشغيل الآلي الجيد بشكل أسرع.

المبدأ 3: بايثون أولاً مع أفضل توافق للغات في فئتها
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

بدأ هذا المبدأ كمبدأ **بايثون أولاً**:

  PyTorch ليس رابطًا في Python لمكتبة C++ أحادية.
  إنه مبني ليكون متكاملاً بشكل عميق مع Python. يمكنك استخدامه
  بشكل طبيعي كما تستخدم `NumPy <https://www.numpy.org/>`__،
  `SciPy <https://www.scipy.org/>`__، `scikit-learn <https://scikit-learn.org/>`__،
  أو مكتبات Python الأخرى. يمكنك كتابة طبقات الشبكة العصبية الجديدة الخاصة بك في Python نفسه،
  باستخدام مكتباتك المفضلة واستخدام الحزم مثل `Cython <https://cython.org/>`__ و
  `Numba <http://numba.pydata.org/>`__. هدفنا هو عدم إعادة اختراع العجلة حيثما يكون ذلك مناسبًا.

أحد الأشياء التي كان على PyTorch التعامل معها على مر السنين هو التغلب على بايثون: لقد أعدنا أولاً كتابة محرك `autograd` في C++، ثم غالبية تعريفات المشغل، ثم قمنا بتطوير TorchScript وواجهة C++ الأمامية.

ومع ذلك، فإن العمل في Python يوفر بسهولة أفضل تجربة لمستخدمينا: فهو مرن، مألوف، وربما الأهم من ذلك، أنه يحتوي على نظام بيئي ضخم من مكتبات ومؤشرات تمديد الحوسبة العلمية المتاحة للاستخدام. تحفز هذه الحقيقة بعضًا من أحدث مساهماتنا، والتي تحاول الوصول إلى نقطة Pareto المثالية بالقرب من نهاية منحنى قابلية استخدام Python:

-  `TorchDynamo <https://dev-discuss.pytorch.org/t/torchdynamo-an-experiment-in-dynamic-python-bytecode-transformation/361>`__،
   أداة تقييم إطار Python القادرة على تسريع برامج PyTorch في الوضع المتلهف الموجودة مع الحد الأدنى من التدخل من المستخدم.
-  `torch_function <https://pytorch.org/docs/main/notes/extending.html#extending-torch>`__
   و `torch_dispatch <https://dev-discuss.pytorch.org/t/what-and-why-is-torch-dispatch/557>`__
   نقاط التمديد، والتي مكنت وظائف Python أولاً من البناء على أساس C++ الداخلي، مثل `tracer torch.fx
   <https://pytorch.org/docs/stable/fx.html>`__
   و `functorch <https://github.com/pytorch/functorch>`__
   على التوالي.

هذه المبادئ التصميمية ليست قواعد ثابتة، ولكنها خيارات صعبة الفوز وترسخ كيف بنينا PyTorch ليكون إطار العمل القابل للتصحيح والمرن والقابل للتخصيص الذي هو عليه اليوم. مع وجود المزيد من المساهمين والقائمين على الصيانة، نتطلع إلى تطبيق هذه المبادئ الأساسية معك عبر مكتباتنا ونظامنا البيئي. نحن منفتحون أيضًا على تطورها مع تعلمنا أشياء جديدة وتطور مجال الذكاء الاصطناعي، كما نعلم أنه سيفعل ذلك.