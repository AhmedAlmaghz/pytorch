الأشكال الديناميكية
============

الرمز: `symbolic_shapes.py <https://github.com/pytorch/pytorch/blob/db4572dbf18f1cf50cf662547e272d3117063747/torch/fx/experimental/symbolic_shapes.py>`_

انظر أيضًا: `دليل الأشكال الديناميكية <https://docs.google.com/document/d/1GgvOe7C8_NVOMLOCwDaYV1mXXyHMXY7ExoewHqooxrs/edit#heading=h.fh8zzonyw8ng>`_

الدافع
------

عادةً ما تعمل برامج التجميع الخاصة بالتعلم العميق فقط للأشكال الثابتة، أي أنها تنتج برامج مجمعة تعمل فقط لتكوين إدخال واحد محدد، ويجب إعادة التجميع إذا تغير أي شكل من أشكال الإدخال. يعمل هذا الافتراض بشكل رائع لمعظم نماذج التعلم العميق التي يتم تشغيلها حاليًا، ولكن هناك بعض الحالات التي لا تكون كافية فيها:

- قد تختلف بعض الأبعاد، مثل حجم الدفعة أو طول التسلسل. على سبيل المثال، ستقوم خدمة الاستدلال التي تقوم بالدفعات التكيفية بتنفيذ طلبات الاستدلال مع أحجام دفعات مختلفة اعتمادًا على عدد الطلبات التي تم تلقيها في نافذة الدفعة الخاصة بها. قد نرغب أيضًا في التفكير في توسيع تسلسلات متغيرة الحجم فقط إلى طول التسلسل الأقصى ضمن دفعة، والتي قد تختلف من دفعة إلى دفعة.
- تُظهر بعض النماذج أشكال إخراج تعتمد على البيانات، أي أن حجم المخرجات والوسيطات قد يعتمد على بيانات الإدخال الفعلية التي قد تختلف عبر التشغيل. على سبيل المثال، قد تقوم نماذج الكشف أولاً بتوليد عدد متغير من صناديق الحدود المحتملة قبل تشغيل نموذج التعرف على الصور الأكثر تكلفة لتحديد ما إذا كان الموضوع موجودًا في صندوق محدد. يعتمد عدد صناديق الحدود على البيانات.
- تحدث حالة مهمة بشكل خاص للأشكال التي تعتمد على البيانات عند التعامل مع التمثيلات المتناثرة، مثل المصفوفات المتناثرة، والمصفوفات غير المنتظمة، وشبكات الأعصاب الرسومية. في كل هذه الحالات، يعتمد مقدار البيانات التي سيتم معالجتها على البنية المتناثرة للمشكلة، والتي ستختلف عادةً بطريقة تعتمد على البيانات.

لدعم الأشكال الديناميكية، اخترنا عدم دعم البرامج الديناميكية ذات الرتب، أي البرامج التي تتغير فيها المصفوفات المدخلة في البعدية، حيث نادرًا ما يحدث هذا النمط في برامج التعلم العميق في العالم الحقيقي، ويتم تجنب الحاجة إلى الاستدلال الاستقرائي على قوائم الأشكال الرمزية.

واجهة برمجة التطبيقات العامة المختصرة
-----------------------------

السلوك الديناميكي الافتراضي في PyTorch 2.1 هو:

- يفترض PT2 أن كل شيء ثابت بشكل افتراضي

- إذا قمنا بإعادة التجميع لأن الحجم قد تغير، فسنحاول بدلاً من ذلك إعادة تجميع
  أن هذا الحجم ديناميكي (من المحتمل أن تتغير الأحجام التي تغيرت في
  المستقبل). قد يفشل هذا التعميم (على سبيل المثال، لأن كود المستخدم يقوم بفرع مشروط على الحجم المعني أو بسبب عدم وجود دعم للأشكال الديناميكية في PT2). إذا كنت تحاول فهم سبب تخصص PT2 المفرط لبعض التعليمات البرمجية، فقم بتشغيله باستخدام ``TORCH_LOGS=dynamic`` وابحث عن إدخالات "eval" التي تشير إلى متى تتم إضافة الحرس ولماذا.

- إذا كنت تعرف مسبقًا أن شيئًا ما سيكون ديناميكيًا، فيمكنك تخطي إعادة التجميع الأولى باستخدام ``torch._dynamo.mark_dynamic(tensor، dim)``. إذا كنت تعرف مسبقًا
  القيمة "min" و "max" التي يمكن أن يأخذها هذا البعد، فيمكنك تحديد ``torch._dynamo.mark_dynamic(tensor، dim، min=min، max=max)``

- إذا قلت ``torch.compile(dynamic=False)``، فسنقوم بتعطيل الأشكال الديناميكية التلقائية عند إعادة التجميع وسنقوم بإعادة التجميع لكل حجم مميز.
  على العكس من ذلك، إذا قلت ``torch.compile(dynamic=True)``، فسنحاول جعل
  كل شيء ديناميكيًا قدر الإمكان. هذا مفيد بشكل أساسي للمشغلين الصغار؛ إذا حاولت ذلك على نموذج كبير، فسيؤدي ذلك إلى (1) تحطم PT2 على الأرجح و
  (2) تشغيل بطيء بدون سبب وجيه.

نموذج الحرس
-----------

عند النظر في كيفية إضافة دعم للأشكال الديناميكية إلى TorchDynamo وTorchInductor، اتخذنا قرارًا تصميميًا رئيسيًا: من أجل إعادة استخدام التحليلات والتعليمات البرمجية الأخرى الموجودة مكتوبة في Python/C++ التي تستهدف واجهة برمجة تطبيقات PyTorch، يجب أن نتمكن من تتبع الأشكال الديناميكية. على عكس النظام الرمزي الكامل الذي قد يلتقط كلا فرعي الشرط، فإننا دائمًا ما نختار فرعًا واحدًا ونخصص أثره بافتراض أننا نستخدم هذا الأثر فقط عندما نتخذ نفس الاختيار لهذا الفرع في المستقبل. للقيام بذلك، نحتفظ بـ "تلميح" لكل حجم رمزي يقول ما هي قيمته الملموسة في وقت التجميع (نظرًا لأن TorchDynamo عبارة عن مترجم Just-In-Time، فهو يعرف دائمًا الأحجام الفعلية للإدخال). عندما نقوم بتنفيذ شرط على مصفوفة، ما علينا سوى استشارة التلميح لمعرفة الفرع الذي يجب اتخاذه.

هذا يبسط بشكل كبير الصيغ الشكلية الرمزية التي ننتجها، ولكنه يعني أن لدينا نظامًا أكثر تعقيدًا لإدارة الحرس. على سبيل المثال، ضع في اعتبارك البرنامج التالي:

.. code-block:: python

    def f(x، y):
        z = torch.cat ([x، y])
        if z.size (0)> 2:
            return z.mul (2)
        else:
            return z.add (2)

سيكون IR النهائي الذي سنقوم بتجميعه باستخدام TorchInductor إما ``torch.cat ([x، y]).add (2)`` أو ``torch.cat ([x، y]).mul (2)`` (مع تسطيح الشرط)، ولكن لتحديد الفرع الذي نحن فيه، يجب أن نعرف حجم ``z``، وهو متوسط. نظرًا لأنه يجب على TorchDynamo أن يعرف مقدمًا ما إذا كان الأثر المجمع صالحًا (لا ندعم عمليات الاسترداد، مثل بعض برامج التجميع JIT)، فيجب أن نتمكن من تقليل ``z.size (0)`` كتعبير من حيث المدخلات، ``x.size (0) + y.size (0)``. يتم ذلك عن طريق كتابة وظائف ميتا لجميع المشغلين في PyTorch والتي يمكنها نشر معلومات الحجم إلى إخراج مصفوفة دون إجراء الحساب فعليًا على العقدة.

الهندسة المعمارية الشاملة
----------------------

سير عمل الأشكال الرمزية:

1. عندما نبدأ بتجميع إطار في دينامو، نقوم بتخصيص ShapeEnv (مرفق بـ FakeTensorMode) والذي يتتبع حالة الأشكال الرمزية.
2. نقوم بتخصيص أحجام رمزية للمصفوفات عند الإدخال (ما هو ثابت أو ديناميكي هو قرار سياسي، مع بعض الأزرار).
3. نقوم بنشر الأحجام الرمزية عبر المشغلين، مع الحفاظ على كل من (1) FX IR بحيث يمكننا تصدير الحساب الرمزي بأمانة، و (2) تعبيرات Sympy التي تمثل متغيرات الحجم، بحيث يمكننا الاستدلال عليها.
4. عندما نشترط على الأحجام الرمزية، سواء في تتبع دينامو أو في تحسين إندكتور، نضيف حراسًا بناءً على الشرطي. يمكن استنتاج هذه من كل من Python و C++.
5. يمكن أن تؤدي هذه الحراس إلى مزيد من التبسيط على المتغيرات الرمزية. على سبيل المثال، إذا أكدت أن "s0 == 4"، فيمكننا الآن استبدال جميع حالات "s0" بـ "4".
6. عندما ننتهي من التتبع والتحسين، نقوم بتثبيت جميع هذه الحراس مع الكود المجمع؛ الكود المجمع قابل لإعادة الاستخدام فقط إذا تم تقييم جميع الحراس على أنها صحيحة.

الملفات المهمة:

- واجهة برمجة التطبيقات SymInt C++: ``c10/core/SymInt.h``، ``SymFloat.h``، ``SymBool.h``
- واجهة برمجة تطبيقات Python SymInt: ``torch/__init__.py`` (ابحث عن ``SymInt/SymFloat/SymBool``)
- السباكة C++: ``c10/core/SymNodeImpl.h``، ``torch/csrc/utils/python_symnode.h``، ``torch/csrc/jit/python/init.cpp``
- البنية التحتية Python: ``torch/fx/experimental/symbolic_shapes.py``
- ملفات مهمة أخرى: ``torch/_subclasses/fake_tensor.py``، ``torch/_meta_registrations.py``، decomps، PrimTorch refs

واجهة برمجة التطبيقات الداخلية المختصرة
--------------------------

فهم التسلسل الهرمي للصفوف في Python:

- SymInt/SymFloat/SymBool: هذه هي الفئات المرئية للمستخدم التي تحاكي نظرائها int/float/bool. إذا أضفت اثنين من SymInts، فسنعطيك SymInt جديدًا يتتبع رمزيًا أن عملية الجمع الصحيحة قد حدثت.
- SymNode: هذا هو الهيكل الداخلي (يمكن الوصول إليه عبر e.g.، ``symint.node``) الذي يحتفظ بمعلومات التتبع الرمزي الفعلية. يتم محو نوع SymNode؛ مما يجعل من الأكثر ملاءمة لتمثيل العمليات المختلطة الأنواع. لاحظ أنه من الناحية الفنية، لا يلزم استدعاء SymNode من SymInt؛ على سبيل المثال، سيحل SymNodeImpl الخاص بـ C++ من XLA محل SymNode.
- ShapeEnv: حالة سياق لكل عملية تجميع والتي تتتبع جميع الرموز الحرة والحراس التي تراكمت لدينا حتى الآن. يسجل كل SymNode ShapeEnv الخاص به (ولكن ليس العكس؛ لا يتم استخدام SymNodes إلا إذا شاركوا في حارس).

C++ مشابه جدًا:

- c10::SymInt/SymFloat/SymBool: فئات مرئية للمستخدم تحاكي int/float/bool.
- c10::SymNode/SymNodeImpl: مماثلة لشركة SymNode
- لا يوجد ShapeEnv في C++؛ لتسهيل التصحيح، توجد آلية الاستدلال الرمزي بأكملها في Python.

عندما تكتب كودًا يمكن تتبعه باستخدام ``make_fx``، يجب أن يكون قادرًا على التعامل مع SymInt/SymFloat/SymBool المتدفقة من خلاله. `دليل الأشكال الديناميكية <https://docs.google.com/document/d/1GgvOe7C8_NVOMLOCwDaYV1mXXyHMXY7ExoewHqooxrs/edit#heading=h.fh8zzonyw8ng>`_ يقدم بعض الإرشادات حول كيفية القيام بذلك.

سياسة DimDynamic
----------------

الاستدلال الرمزي:

- نطاقات القيم
- ملاحظات استخدام Sympy
- القيود
- DimDynamic/Constraint

SymInts غير المدعومة
--------------------

لحل التحكم في التدفق، نتحقق من التلميح، أي القيمة الفعلية، لعدد صحيح رمزي لتحديد الفرع الذي يجب الانتقال إليه. ومع ذلك، في بعض الحالات، قد لا يكون لدينا تلميح: تنشأ الأعداد الصحيحة الرمزية غير المدعومة عندما تظهر متغيرات الحجم من عملية تعتمد على البيانات مثل ``.nonzero()`` أو ``.item()``. من غير القانوني إجراء التحكم في التدفق على هذه الأعداد الصحيحة الرمزية، لذلك يجب علينا كسر الرسم البياني على هذه العمليات.

إذا تم تنفيذه بشكل ساذج، يكون هذا تقييديًا للغاية: ستفشل معظم برامج PyTorch على الفور إذا حاولت القيام بأي شيء باستخدام الأعداد الصحيحة الرمزية غير المدعومة. فيما يلي أهم التحسينات لجعل هذا الأمر يعمل بالفعل:

- عند إنشاء مصفوفة، تقوم PyTorch مسبقًا بحساب الكثير من البيانات حول مصفوفة؛ على سبيل المثال، إذا استخدمت ``empty_strided`` لإنشاء مصفوفة، فسنقوم بفرز الخطوات مسبقًا وتحديد ما إذا كانت المصفوفة غير متداخلة وكثيفة. تنتج الفرزات الكثير من الحراس. ومع ذلك، من الأكثر شيوعًا إنتاج مصفوفة مباشرة باستخدام واجهة برمجة تطبيقات ذات مستوى أعلى مثل ``empty``، والتي تضمن إنتاج مصفوفة غير متداخلة وكثيفة. لقد قمنا بتعديل PyTorch لتجنب إعادة حساب هذه الخصائص بلا داع.
- حتى إذا كانت هناك حاجة إلى حسابات غير بسيطة، ففي بعض الأحيان لا يتم استعلام خاصية على الإطلاق. يجعل جعل هذه الخصائص المحسوبة مسبقًا كسولة تجنب الحماية على عدد صحيح رمزي غير مدعوم ما لم يكن مطلوبًا بالفعل.
- لا تُعرف البيانات الموجودة في مصفوفة الأعداد الصحيحة على أنها غير سالبة. ومع ذلك، نوفر واجهة برمجة تطبيقات ``constrain_range`` يمكن للمستخدم من خلالها تحديد أن الحجم محدود من الأعلى والأسفل بحدود معروفة.

في الإصدارات المستقبلية من PT2 (بعد PT2.1)، سنقوم بتوسيع نظام الاستدلال لدينا
لاستنتاج أن عددًا صحيحًا رمزيًا غير مدعوم يعتمد على الحجم بناءً على الاستخدام.  على سبيل المثال، إذا قمت بتمرير نتيجة مكالمة ``.item()`` إلى دالة مصنع
مثل ``torch.empty``، فسنفترض تلقائيًا أن النتيجة هي حجم
(لأنه إذا لم يكن كذلك، فسوف يفشل.)  سيتم التحقق من هذا الافتراض في وقت التشغيل، مما يؤدي إلى حدوث خطأ إذا لم يتم الوفاء به.